{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "wU4OsK_AQDLR"
   },
   "source": [
    "# Analysis of different Major League Baseball player salaries\n",
    "By: Austin Kaminow & Joshua Leeman"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "p33egwatPzDR"
   },
   "source": [
    "# Introduction / Motivation\n",
    "\n",
    "Anybody who looks at the current salaries of the highest paid baseball players these days is immediately in awe. Max Scherzer recently set a record, making over 43 million dollars per year. Several players are making over 30 million, and over 50 MLB players are making at least 20 million dollars per year. Our work is an exploration into these salaries, seeing how much players really deserve such salaries. We will compare players to one another, taking note of how well they perform compared to other players, and how much money they make compared to other players. To learn more about the highest paid baseball players today, please look at https://www.nbcsports.com/washington/nationals/here-are-highest-paid-mlb-players-2022-season.\n",
    "<br><br>\n",
    "In this project, we will look both at batters and pitchers, comparing batters' salaries to other batters' salaries, and doing the same for pitchers. Our null hypothesis is that a player's performances has no affect on his salary. We hope to reject this null hypothesis, showing that there is indeed a correlation between these high-paid baseball players and their actual performace throughout the season.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "qrxm0wuPS-R7"
   },
   "source": [
    "# Data Collection\n",
    "\n",
    "In this section, we will collect data for the batters and pitchers. In order to get all of the information we need for each player, we will also need to gather information from the salaries data table. We will then combine the salaries with the batters as well as with pitchers in order to view each player and their salary in the same dataframe.\n",
    "<br><br>\n",
    "In this first section, we begin by gathering the data from these data sets, and limiting them to the years between 1985 and 2016. Unfortunately, we were not able to find salary data that went beyond the year 2016."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "C6ps3H3Y53_z",
    "outputId": "ab7c15ee-462b-48ac-f795-8dc12a07e775"
   },
   "outputs": [],
   "source": [
    "# Imports\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import datetime\n",
    "\n",
    "# Gathering csv files and condensing to the 22 years between 1985 and 2016\n",
    "data_batting = pd.read_csv(\"Batting.csv\")\n",
    "data_batting = data_batting[data_batting.yearID >= 1985][data_batting.yearID <= 2016]\n",
    "\n",
    "data_pitching = pd.read_csv(\"Pitching.csv\")\n",
    "data_pitching = data_pitching[data_pitching.yearID >= 1985][data_pitching.yearID <= 2016]\n",
    "\n",
    "data_salaries = pd.read_csv(\"Salaries.csv\")\n",
    "data_salaries = data_salaries[data_salaries.yearID >= 1985][data_salaries.yearID <= 2016]\n",
    "\n",
    "data_people = pd.read_csv(\"People.csv\")\n",
    "\n",
    "# Condense the data to only include players playing between 1985 and 2016\n",
    "data_people = data_people.dropna(subset = ['debut'])\n",
    "def check_career(row) :\n",
    "  if int(str(row['finalGame'])[:4]) <= 1985 or int(str(row['debut'])[:4]) >= 2016:\n",
    "    return 'no'\n",
    "  return 'yes'\n",
    "\n",
    "data_people['career'] = data_people.apply (lambda row: check_career(row), axis=1)\n",
    "data_people = data_people[data_people['career'] == 'yes']\n",
    "\n",
    "#Drop unnecessary columns from the people dataframe\n",
    "data_people = data_people.drop(['birthYear', 'birthMonth', 'birthDay', \n",
    "                                'birthCountry', 'birthState', 'birthCity', 'deathYear', 'deathMonth', 'deathDay', \n",
    "                                'deathCountry', 'deathState', 'deathCity', 'weight', 'height'], axis=1)\n",
    "data_people = data_people.reset_index()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "DbzLdokrUwC8"
   },
   "source": [
    "Below, we are going to show the first few rows of the dataframes we will be working with throughout this project. The order these are shown is:\n",
    "<br>\n",
    "1) Batting\n",
    "<br>\n",
    "2) Pitching\n",
    "<br>\n",
    "3) Salaries\n",
    "<br>\n",
    "4) People"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 392
    },
    "id": "AL4dZ5l0W8kK",
    "outputId": "f81879bb-b3e5-44ba-d403-3a7ed4983b21"
   },
   "outputs": [],
   "source": [
    "data_batting.head(10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 392
    },
    "id": "pYJ8HcYOnNag",
    "outputId": "435e29ae-4aff-4139-f437-5edef42a9f0d"
   },
   "outputs": [],
   "source": [
    "data_pitching.head(10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 363
    },
    "id": "fbMytlHYnNig",
    "outputId": "31133615-e0a7-43f6-cd00-2c965e39b34a"
   },
   "outputs": [],
   "source": [
    "data_salaries.head(10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 407
    },
    "id": "0HMjg_crnNmO",
    "outputId": "32450710-22c6-49c6-d445-f14e6f6ee2fc"
   },
   "outputs": [],
   "source": [
    "data_people.head(10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "2148F2rjnstm"
   },
   "source": [
    "#Data Management and Representation\n",
    "\n",
    "Now that we have our data sets loaded into dataframes, we will add some necessary columns to our dataframes that will be instrumental in testing our hypothesis. We will use some graphs to explain why each additional column of the dataframe is necessary."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 295
    },
    "id": "dt4HIyeeBUpb",
    "outputId": "1b5082a8-8efa-4f8a-e382-123f09bcfba4"
   },
   "outputs": [],
   "source": [
    "# Create a bar graph of the total salaries per year\n",
    "\n",
    "#Create dictionary to stores total payroll as values, and years as keys\n",
    "salaries = {}\n",
    "\n",
    "#Add each year to the dictionary\n",
    "for year in data_salaries['yearID'].unique():\n",
    "  salaries[year] = 0\n",
    "\n",
    "#Calculate total payroll per year\n",
    "for index, row in data_salaries.iterrows():\n",
    "  salaries[row.yearID] += row.salary\n",
    "\n",
    "#Create the plot\n",
    "plt.bar(salaries.keys(), salaries.values())\n",
    "plt.ylabel(\"Total Salary\")\n",
    "plt.xlabel(\"Year\")\n",
    "plt.title(\"Total salary for each year\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "xz3EhT8HoQtS"
   },
   "source": [
    "To start off, we will address the issue of the fact that baseball players get paid more now than in 1985. Baseball is much more popular than it has been before, the league minimum is rising, and the superstars are being paid hundreds of times what they used to. Because of this, we will add a column in our dataframe that represents the fraction of the total payroll a player is being paid. This will allow us to compare salaries between then 2010's and 1980's without too much trouble."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 402
    },
    "id": "I-zajemfV1gj",
    "outputId": "2d121fc8-0f70-4c60-afcd-3a89abc00afc"
   },
   "outputs": [],
   "source": [
    "#Create violin plot of each players salary per year\n",
    "\n",
    "#Convert salary to a fraction of the total payroll for that year\n",
    "def salary_fraction (row):\n",
    "  return row.salary / salaries[row.yearID]\n",
    "\n",
    "data_salaries['salary_fraction'] = data_salaries.apply (lambda row: salary_fraction(row), axis=1)\n",
    "\n",
    "#Create dictionary to store salary fractions as values and years as keys\n",
    "salaries_fractions = {}\n",
    "\n",
    "#Add all years to the dictionary\n",
    "for year in data_salaries['yearID'].unique():\n",
    "  salaries_fractions[year] = []\n",
    "\n",
    "#Add each player's salary fraction to the dictionary\n",
    "for index, row in data_salaries.iterrows():\n",
    "  salaries_fractions[row['yearID']].append(row.salary_fraction)\n",
    "\n",
    "    \n",
    "#Create the plot\n",
    "fig_res, ax_res = plt.subplots()\n",
    "\n",
    "ax_res.violinplot(salaries_fractions.values(),salaries_fractions.keys(),widths=4,showmeans=True)\n",
    "ax_res.set_xlabel(\"Year\")\n",
    "ax_res.set_ylabel(\"Fraction of the Total Salary\")\n",
    "ax_res.set_title(\"Salary of Each Player in Comparison to Total Payroll by Year\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "rB6JdjbIo_8m"
   },
   "source": [
    "This graph is clearly very difficult to understand, so we will group time frames in terms of five years each. This will help us interperet graphs much easier."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 312
    },
    "id": "tLT1p-zVoveW",
    "outputId": "9e681aec-fab7-40fe-f70c-e7aed247ae7d"
   },
   "outputs": [],
   "source": [
    "#Create a violin plot of each players salary per five year span\n",
    "\n",
    "#Round down to the nearest 5\n",
    "def round_down_5(row):\n",
    "  n = row['yearID']\n",
    "  return n//5*5\n",
    "\n",
    "data_salaries['5_year_span_start'] = data_salaries.apply (lambda row: round_down_5(row), axis=1)\n",
    "\n",
    "\n",
    "#Create dictionary to store salary fractions as values and years as keys\n",
    "salaries_fractions = {}\n",
    "\n",
    "#Add all five year spans to the dictionary by starting year\n",
    "for year in data_salaries['5_year_span_start'].unique():\n",
    "  salaries_fractions[year] = []\n",
    "\n",
    "#Add each player's salary fraction to the dictionary\n",
    "for index, row in data_salaries.iterrows():\n",
    "  salaries_fractions[row['5_year_span_start']].append(row.salary_fraction)\n",
    "\n",
    "    \n",
    "    \n",
    "#Create the plot\n",
    "fig_res, ax_res = plt.subplots()\n",
    "\n",
    "ax_res.violinplot(salaries_fractions.values(),salaries_fractions.keys(),widths=4,showmeans=True)\n",
    "ax_res.set_xlabel(\"5 Year Span Starting Year\")\n",
    "ax_res.set_ylabel(\"Fraction of the Total Salary\")\n",
    "ax_res.set_title(\"Salary of Each Player in Comparison to Total Payroll by Five Year Span\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "h0lXGLwZXH2f"
   },
   "source": [
    "That's much better! We can see through this violin plot that relative to other players, each player has continued to be paid a similar amount. The overwhelming majority of players make around .001 of the total payroll, with the mean being around .0015 to .002 each year. This will be a better measure to use when comparing data throughout different years.\n",
    "\n",
    "Now let's add that data to our batters and pitchers dataframes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 392
    },
    "id": "lw-SprckVwjN",
    "outputId": "cd8e6cde-b37d-42cb-c7f7-2be3f7125e1e"
   },
   "outputs": [],
   "source": [
    "data_batting.head(10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "WnPu2qDwD8_p"
   },
   "outputs": [],
   "source": [
    "#Merge the batters data with the salary information\n",
    "batters = data_batting.merge(\n",
    "     data_salaries,\n",
    "     on=[\"yearID\", \"playerID\"],\n",
    "     how=\"left\",\n",
    " )\n",
    "\n",
    "#Drop all batters whose salary is not available\n",
    "batters = batters.dropna(subset = ['salary'])\n",
    "\n",
    "#Merge the pitchers data with the salary information\n",
    "pitchers = data_pitching.merge(\n",
    "     data_salaries,\n",
    "     on=[\"yearID\", \"playerID\"],\n",
    "     how=\"left\",\n",
    " )\n",
    "\n",
    "#Drop all pitchers whose salary is not available\n",
    "pitchers = pitchers.dropna(subset = ['salary'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "MggEE-9O_X8p"
   },
   "source": [
    "Now let's only look at a select subset of the batters and pitchers. We only want the players who played enough games in the season."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "ASLpYERa_XSs"
   },
   "outputs": [],
   "source": [
    "#Drop all batters who had fewer than 100 AB for a given year\n",
    "batters = batters[batters.AB > 100]\n",
    "\n",
    "#Drop all pitchers who appeared in fewer than 30 games for a given year\n",
    "pitchers = pitchers[pitchers.G > 30]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "38QbumfjAJzs"
   },
   "source": [
    "We also don't want to look at players on their rookie contracts, as those tend to be far too high or far too low very often. So let's only look at players who have been in the majors for at least 5 years."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "j3biLKZ5ASOW"
   },
   "outputs": [],
   "source": [
    "# Merging all career lengths to associated pitchers\n",
    "pitchers = pd.merge(pitchers, data_people, on='playerID', how='inner')\n",
    "\n",
    "# Merging all career lengths to associated batters\n",
    "batters = pd.merge(batters, data_people, on='playerID', how='inner')\n",
    " \n",
    "# Only accounting for pitchers playing for at least 5 years since they will have signed a larger contract\n",
    "pitchers['career_length'] = pitchers.apply (lambda row: row['yearID'] - int(str(row['debut'])[:4]), axis=1)\n",
    "pitchers = pitchers[pitchers.career_length >= 5]\n",
    "\n",
    "# Only accounting for batters playing for at least 5 years since they will have signed a larger contract\n",
    "batters['career_length'] = batters.apply (lambda row: row['yearID'] - int(str(row['debut'])[:4]), axis=1)\n",
    "batters = batters[batters.career_length >= 5]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "PzZ_0HKtpQzH"
   },
   "source": [
    "Now let's see what we have in terms of statistics for our batters then our pitchers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "k42K2rRIBMSZ",
    "outputId": "521ad5a3-90be-411c-c528-1a81ab3008dc"
   },
   "outputs": [],
   "source": [
    "batters.columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "08fD-SMOBMUs",
    "outputId": "64c6cbea-d986-4a3e-ad31-eb389b95d6c8"
   },
   "outputs": [],
   "source": [
    "pitchers.columns"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "15GP0hHoddRt"
   },
   "source": [
    "That's looking pretty good, but we seem to be missing a few key statistics. Let's add OPS and batting average for the batters. Check https://honestbaseball.com/baseball-statistics/ for more information on these statistics."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 630
    },
    "id": "J3AVtjx2dpID",
    "outputId": "8b35360f-e846-4cce-a3f5-e280efcc28c0"
   },
   "outputs": [],
   "source": [
    "#Create column for batter's OPS\n",
    "def ops (row):\n",
    "  slugging = (row['H'] + row['2B'] + 2 * row['3B'] + 3 * row['HR']) / row['AB']\n",
    "  OBP = (row['BB'] + row['IBB'] + row['HBP'] + row['H']) / (row['AB'] + row['BB'] + row['IBB'] + row['SH'] + row['SF'] + row['HBP'])\n",
    "  return slugging + OBP\n",
    "\n",
    "batters['OPS'] = batters.apply (lambda row: ops(row), axis = 1)\n",
    "\n",
    "#Create column for batter's batting average\n",
    "batters['AVG'] = batters['H'] / batters['AB']\n",
    "\n",
    "batters.head(10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "EPdEWD4CCTiS"
   },
   "source": [
    "Now let's add those key statistics for the pitchers. We will add the strikeout and walk percentages for each of the pitchers. Check https://honestbaseball.com/baseball-statistics/ for more information on these statistics."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 630
    },
    "id": "Nz0iNzepCTI2",
    "outputId": "b8880bdc-c845-4139-e336-5929098f117b"
   },
   "outputs": [],
   "source": [
    "#Create column for pitcher's walk percentage\n",
    "pitchers['BB%'] = pitchers['BB'] / pitchers['IPouts']\n",
    "\n",
    "#Create column for pitcher's strikeout percentage\n",
    "pitchers['SO%'] = pitchers['SO'] / pitchers['IPouts']\n",
    "\n",
    "pitchers.head(10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "PK0P54NvCr52"
   },
   "source": [
    "#Data Exploration\n",
    "Let's begin our exploration of the data by looking at our batters. As mentioned above, the three statistics we will be looking into are their OPS, batting average, and home runs. To preliminarily explore these three statistics, we are going to compare the players who make above .15% of the total payroll to those who do not. .15% seems to be approximately the mean for each year, as seen in the violin plot above."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 851
    },
    "id": "DQxxq00Betjl",
    "outputId": "45e6acb3-22b7-400c-c9b2-6174ef9ab31a"
   },
   "outputs": [],
   "source": [
    "#Create column to indicate if batters are paid more than .15% of the total payroll\n",
    "batters['high_paid'] = batters.apply (lambda row: row['salary_fraction'] > 0.0015, axis=1)\n",
    "\n",
    "#Create dictionary for average values of each statistic per five year span\n",
    "stat_avg = {}\n",
    "\n",
    "#Graph the players making above .15% of the total payroll vs those making less by statistic\n",
    "for stat in ['OPS', 'AVG', 'HR']:\n",
    "  stat_avg[stat] = []\n",
    "  \n",
    "  #Create dictionary for those making less than .15% of the total payroll\n",
    "  player_stats_low = {}\n",
    "\n",
    "  #Create dictionary for those making more than .15% of the total payroll\n",
    "  player_stats_high = {}\n",
    "  \n",
    "  for span in batters['5_year_span_start'].unique():\n",
    "    \n",
    "    #Add average value for that stat to stat_avg dictionary\n",
    "    year_mean = batters.loc[batters['5_year_span_start'] == span, stat].mean()\n",
    "    stat_avg[stat].append(year_mean)\n",
    "   \n",
    "    #Add average value for that stat among player's making less than .15% of total payroll to year_mean_low dictionary\n",
    "    year_mean_low = batters.loc[(batters['5_year_span_start'] == span) & (batters['high_paid'] == False), stat].mean()\n",
    "    player_stats_low[span] = year_mean_low\n",
    "\n",
    "    #Add average value for that stat among player's making more than .15% of total payroll to year_mean_high dictionary\n",
    "    year_mean_high = batters.loc[(batters['5_year_span_start'] == span) & (batters['high_paid'] == True), stat].mean()\n",
    "    player_stats_high[span] = year_mean_high\n",
    "\n",
    "  #Create the plot\n",
    "  plt.bar(player_stats_low.keys(), player_stats_low.values(), 3, label = \"Low Salaries\")\n",
    "  plt.bar(player_stats_high.keys(), player_stats_high.values(), 1, label = \"High Salaries\")\n",
    "  plt.ylabel(\"Average \" + stat)\n",
    "  plt.xlabel(\"Year\")\n",
    "  plt.title(\"Comparing average \" + stat + \" for each year\")\n",
    "  plt.legend()\n",
    "  plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "ddjUx_BPk9RE"
   },
   "source": [
    "Clearly there is some difference between the players who get paid more and those who get paid less. In order to investigate further, let's create an interaction term to combine these three statistics. Since the home runs seem to be much more indicative of more pay, we will weight home runs higher for our interaction term."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "D11LPv4jlCRJ"
   },
   "outputs": [],
   "source": [
    "#Create interaction term column for each of our batters\n",
    "def get_interaction (row):\n",
    "  span = row['5_year_span_start']\n",
    "  norm_ops = row['OPS'] / stat_avg['OPS'][int((span-1985)//5)]\n",
    "  norm_avg = row['AVG'] / stat_avg['AVG'][int((span-1985)//5)]\n",
    "  norm_hr = row['HR'] / stat_avg['HR'][int((span-1985)//5)]\n",
    "  return (norm_ops + norm_avg + 2 * norm_hr) / 4\n",
    "\n",
    "\n",
    "batters['interaction_term'] = batters.apply(lambda row: get_interaction(row), axis = 1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "iyidKGGBYYFQ"
   },
   "source": [
    "Let's see those interaction terms we just generated"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 630
    },
    "id": "w0SRb7lQYaiz",
    "outputId": "0e407c0e-968c-49cb-8d9f-3f70da412593"
   },
   "outputs": [],
   "source": [
    "batters.head(10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "k9wML8MFYm3Z"
   },
   "source": [
    "Let's now look at a violin plot of the interaction terms for each player. This plot will be very helpful, as we can see not just what the mean is, but also what the distribution is. Clearly, based on how the interaction term was calculated, the mean will be 1 for each five year span. This, however, will let us compare the distributions among each five year span."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 402
    },
    "id": "YXWyighVmQbd",
    "outputId": "5f2c9621-e1b6-411e-975d-19f943998da8"
   },
   "outputs": [],
   "source": [
    "#Create dictionary for interaction terms by five year span\n",
    "term_means = {}\n",
    "\n",
    "#For each batter, add there interaction term to the right five year span\n",
    "for index, row in batters.iterrows():\n",
    "  if row['5_year_span_start'] not in term_means.keys():\n",
    "    term_means[row['5_year_span_start']] = []\n",
    "  term_means[row['5_year_span_start']].append(row['interaction_term'])\n",
    "    \n",
    "#Create the plot\n",
    "fig_res, ax_res = plt.subplots()\n",
    "\n",
    "ax_res.violinplot(term_means.values(), term_means.keys(), widths=4,showmeans=True)\n",
    "ax_res.set_xlabel(\"5 Year Span Starting Year\")\n",
    "ax_res.set_ylabel(\"Interaction Term\")\n",
    "ax_res.set_title(\"Interaction term of players by year\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "yAIrhxd1Y5o-"
   },
   "source": [
    "This is great news! We can see that the distributions among all seven five year spans look very similar. This, along with the fact that the salary fraction distributions look similar, will allow for the ability to actually compare these two values among different five year spans."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "ix2EaXRWZKMS"
   },
   "source": [
    "Now that we know that the salary fraction and interaction terms should have roughly the same distributions throughout all of our five year spans, let's do some graphing. Because these two values have consistent distributions throughout all spans, we will be able to include all players from any time span in our scatterplot. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 295
    },
    "id": "RkTQMyyYBVbn",
    "outputId": "1e0601d7-a8d6-4614-bfda-64170edc9560"
   },
   "outputs": [],
   "source": [
    "#Create scatterplot of all batters interaction terms\n",
    "plt.scatter(batters['interaction_term'], batters['salary_fraction'])\n",
    "plt.xlabel(\"Interaction Term\")\n",
    "plt.ylabel(\"Salary Fraction\")\n",
    "plt.title(\"Salary for each player by interaction term\")\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "HW2D_qQAaDyf"
   },
   "source": [
    "As assumed, this is a very messy scatterplot. With thousands of data points, we are not able to see very much information from this plot. In order to see a bit more information from our plot, let's create salary brackets. Instead of looking at the exact salary fraction of each player, we can look at their salary bracket. Let's make each bracket the size of .05% of the total payroll. For example, all players who make betwenn .1% and .15% of the total payroll will be put in the same bracket. This will limit total datapoints in order to more easily interperet our scatterplot."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 295
    },
    "id": "oBRQvZg8EGJN",
    "outputId": "1f9d1bde-2cac-4bcd-b0cf-f1d97fb9f1ce"
   },
   "outputs": [],
   "source": [
    "#Round down to the nearest .0005 = .05%\n",
    "def round_down_0005(row):\n",
    "  n = row['salary_fraction'] * 10000\n",
    "  return n // 5 * 5 / 10000\n",
    "\n",
    "#Create a salary bracket for each batter\n",
    "batters['salary_bracket'] = batters.apply (lambda row: round_down_0005(row), axis=1)\n",
    "\n",
    "#Create a dictionary for the interaction terms by salary bracket\n",
    "brackets = {}\n",
    "\n",
    "#Add the average interaction term for each salary bracket to brackets dictionary\n",
    "for brack in batters['salary_bracket'].unique():\n",
    "  brackets[brack] = batters.loc[batters['salary_bracket'] == brack, 'interaction_term'].mean()\n",
    "\n",
    "#Make the plot\n",
    "plt.scatter(brackets.values(), brackets.keys())\n",
    "plt.xlabel(\"Salary Bracket\")\n",
    "plt.ylabel(\"Interaction Term\")\n",
    "plt.title(\"Salary bracket based on interaction term\")\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "QL2jBG58bUoE"
   },
   "source": [
    "That is a much nicer looking graph. We will go into more depth on it when we formally test our hypothesis. For now, however, let's look at the pitchers. We will begin in the same way we did with our batters. let's look at a few statistics, and compare how the high paid players did compared to the lower paid ones."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 1000
    },
    "id": "FoHkrySXbyuG",
    "outputId": "e7acb5d2-698e-49ea-fefb-db0da4616f73"
   },
   "outputs": [],
   "source": [
    "#Create column to indicate if pitchers are paid more than .15% of the total payroll\n",
    "pitchers['high_paid'] = pitchers.apply (lambda row: row['salary_fraction'] > 0.0015, axis=1)\n",
    "\n",
    "#Create dictionary for average values of each statistic per five year span\n",
    "stat_avg = {}\n",
    "\n",
    "#Graph the players making above .15% of the total payroll vs those making less by statistic\n",
    "for stat in ['BB%', 'SO%', 'BAOpp', 'ERA', 'IPouts']:\n",
    "  stat_avg[stat] = []\n",
    "  \n",
    "  #Create dictionary for those making less than .15% of the total payroll\n",
    "  player_stats_low = {}\n",
    "\n",
    "  #Create dictionary for those making more than .15% of the total payroll\n",
    "  player_stats_high = {}\n",
    "  \n",
    "  for span in pitchers['5_year_span_start'].unique():\n",
    "    \n",
    "    #Add average value for that stat to stat_avg dictionary\n",
    "    year_mean = pitchers.loc[pitchers['5_year_span_start'] == span, stat].mean()\n",
    "    stat_avg[stat].append(year_mean)\n",
    "   \n",
    "    #Add average value for that stat among player's making less than .15% of total payroll to year_mean_low dictionary\n",
    "    year_mean_low = pitchers.loc[(pitchers['5_year_span_start'] == span) & (pitchers['high_paid'] == False), stat].mean()\n",
    "    player_stats_low[span] = year_mean_low\n",
    "\n",
    "    #Add average value for that stat among player's making more than .15% of total payroll to year_mean_high dictionary\n",
    "    year_mean_high = pitchers.loc[(pitchers['5_year_span_start'] == span) & (pitchers['high_paid'] == True), stat].mean()\n",
    "    player_stats_high[span] = year_mean_high\n",
    "\n",
    "  #Create the plot\n",
    "  plt.bar(player_stats_low.keys(), player_stats_low.values(), 3, label = \"Low Salaries\")\n",
    "  plt.bar(player_stats_high.keys(), player_stats_high.values(), 1, label = \"High Salaries\")\n",
    "  plt.ylabel(\"Average \" + stat)\n",
    "  plt.xlabel(\"Year\")\n",
    "  plt.title(\"Comparing average \" + stat + \" for each year\")\n",
    "  plt.legend()\n",
    "  plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "S1kgUOv9dlos"
   },
   "source": [
    "Fantastic! We have gotten similar results to those of the batters. Clearly there is some difference between the players who get paid more and those who get paid less. In order to investigate further, let's create an interaction term to combine these three statistics. Since the innings pitched seem to be much more indicative of more pay, we will weight those higher for our interaction term."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "EKRSEJ1gfRk_"
   },
   "outputs": [],
   "source": [
    "#Create interaction term column for each of our pitchers\n",
    "def get_interaction(row) :  \n",
    "  k_avg = row['SO%'] / stat_avg['SO%'][int((span-1985)//5)]\n",
    "  bb_avg = row['BB%'] / stat_avg['BB%'][int((span-1985)//5)]\n",
    "  era = row['ERA'] / stat_avg['ERA'][int((span-1985)//5)]\n",
    "  baopp = row['BAOpp'] / stat_avg['BAOpp'][int((span-1985)//5)]\n",
    "  inn = row['IPouts'] / stat_avg['IPouts'][int((span-1985)//5)]\n",
    "\n",
    "  return (k_avg - bb_avg - era - baopp + 2 * inn) / 6\n",
    "\n",
    "pitchers['interaction_term'] = pitchers.apply(lambda row: get_interaction(row), axis = 1)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "3jP7V8cEfW-7"
   },
   "source": [
    "Let's see those interaction terms we just generated"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 630
    },
    "id": "vxbHtC6GfYBs",
    "outputId": "a3830130-c015-4806-8523-14cbb0a0bb72"
   },
   "outputs": [],
   "source": [
    "pitchers.head(10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "Aray6REtfpXX"
   },
   "source": [
    "Let's now look at a violin plot of the interaction terms for each player. This plot will be very helpful, as we can see not just what the mean is, but also what the distribution is. Clearly, based on how the interaction term was calculated, the mean will be 1 for each five year span. This, however, will let us compare the distributions among each five year span."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 419
    },
    "id": "yrpH4iChfqXk",
    "outputId": "6a8c953e-7cc9-4bce-ab63-a38ec83e8909"
   },
   "outputs": [],
   "source": [
    "term_means = {}\n",
    "\n",
    "for index, row in pitchers.iterrows():\n",
    "  if row['5_year_span_start'] not in term_means.keys():\n",
    "    term_means[row['5_year_span_start']] = []\n",
    "  term_means[row['5_year_span_start']].append(row['interaction_term'])\n",
    "\n",
    "fig_res, ax_res = plt.subplots()\n",
    "    \n",
    "#Create the plot\n",
    "ax_res.violinplot(term_means.values(), term_means.keys(), widths=4,showmeans=True)\n",
    "ax_res.set_xlabel(\"5 Year Span Starting Year\")\n",
    "ax_res.set_ylabel(\"Interaction Term\")\n",
    "ax_res.set_title(\"Interaction term of players by year\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "OeJYsCFZf3PC"
   },
   "source": [
    "Similarly to the batters, we see very similar distributions throughout the years. It varies slightly more than it did with the batters, but they are still similar enough that results among different years will still be quite meaningful."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "SBxrs3LOgOgs"
   },
   "source": [
    "Now that we know that the salary fraction and interaction terms should have roughly the same distributions throughout all of our five year spans, let's make the same scatterplot for pitching as we did for batting."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 295
    },
    "id": "Ix4cZaA9gUfN",
    "outputId": "139f3ed4-bfae-48ab-b791-044a782c7670"
   },
   "outputs": [],
   "source": [
    "#Create scatterplot of all pitchers interaction terms\n",
    "plt.scatter(pitchers['interaction_term'], pitchers['salary_fraction'])\n",
    "plt.xlabel(\"Interaction Term\")\n",
    "plt.ylabel(\"Salary Fraction\")\n",
    "plt.title(\"Salary for each player by interaction term\")\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "L49I3BzIglSj"
   },
   "source": [
    "As was the case with the batters, this is a very messy scatterplot. With thousands of data points, we are not able to see very much information from this plot. In order to see a bit more information from our plot, let's create salary brackets, just as we did for our batters."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 295
    },
    "id": "i0n2e2WUglSk",
    "outputId": "412a04f4-1af1-40c8-d2bb-4cd1ffb0d6f5"
   },
   "outputs": [],
   "source": [
    "def round_down_0005(row):\n",
    "  n = row['salary_fraction'] * 10000\n",
    "  return n // 5 * 5 / 10000\n",
    "\n",
    "pitchers['salary_bracket'] = pitchers.apply (lambda row: round_down_0005(row), axis=1)\n",
    "\n",
    "brackets = {}\n",
    "\n",
    "for brack in pitchers['salary_bracket'].unique():\n",
    "  brackets[brack] = pitchers.loc[pitchers['salary_bracket'] == brack, 'interaction_term'].mean()\n",
    "\n",
    "\n",
    "plt.scatter(brackets.values(), brackets.keys())\n",
    "plt.xlabel(\"Interaction Term\")\n",
    "plt.ylabel(\"Salary Bracket\")\n",
    "plt.title(\"Salary bracket based on interaction term\")\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "XZk8yi_SOsie"
   },
   "source": [
    "We see a huge amount of correlation between the salary bracket and the interaction term here. Now that we have looked into our pitchers and batters, let's test our initial hypothesis."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "3hC1iNHQg81A"
   },
   "source": [
    "#Hypothesis Testing\n",
    "\n",
    "In case you don't remember, our null hypothesis for this experiment is that a player's performace has no impact on the player's salary. We are trying to prove that, in fact, there is a correlation between these two values. We have presented a fair amount of graphs in order to explore our data, and to test our hypothesis, we are going to look at a few of the graphs more closely."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "ZekTJIRrhVQ6"
   },
   "source": [
    "Let's begin again with our batters. We will look at the scatterplot from above. This time, however, we will include a trendline. Recall that looking at exact salaries resulted in a very messy graph that looked to be filled with points. Because of this, we will use the graph with salary brackets in order to test our hypothesis."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 295
    },
    "id": "nFVNeMY3hfi2",
    "outputId": "802f07b3-346d-4b7e-d431-4d64adf96fdf"
   },
   "outputs": [],
   "source": [
    "from sklearn.linear_model import LinearRegression\n",
    "import numpy as np\n",
    "\n",
    "brackets = {}\n",
    "\n",
    "for brack in batters['salary_bracket'].unique():\n",
    "  brackets[brack] = batters.loc[batters['salary_bracket'] == brack, 'interaction_term'].mean()\n",
    "\n",
    "\n",
    "y = np.array(list(brackets.keys())).reshape(-1,1)\n",
    "x = np.array(list(brackets.values())).reshape(-1,1)\n",
    "\n",
    "#Initialize and fit the model\n",
    "reg_bat = LinearRegression()\n",
    "reg_bat.fit(x, y)\n",
    "\n",
    "plt.plot(x, reg_bat.predict(x))\n",
    "\n",
    "plt.scatter(brackets.values(), brackets.keys())\n",
    "plt.xlabel(\"Interaction Term\")\n",
    "plt.ylabel(\"Salary Bracket\")\n",
    "plt.title(\"Salary bracket based on interaction term\")\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "_RHAWez_iXlO"
   },
   "source": [
    "That looks pretty promising. Let's calculate the R-squared value to make sure there is a correlation between the interaction term and the salary bracket."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "h36Le3jziiVE",
    "outputId": "385ed733-9b2a-40a1-ce4f-1b2df176285d"
   },
   "outputs": [],
   "source": [
    "# compute with formulas from the theory\n",
    "guess = reg_bat.predict(x)\n",
    "residuals = sum((y-guess)**2)       \n",
    "total = sum((y-np.mean(y))**2)     \n",
    "r_squared = 1 - residuals/total\n",
    "print(r_squared)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "Nc_YXppuin_r"
   },
   "source": [
    "We see that our R-squared value is .799. That is certainly high enough to show a correlation between the salary of the batters and their performace. We can therefore reject the null hypothesis in terms of the batters. Let's look now towards the pitchers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 295
    },
    "id": "EY3SJJBMi2BP",
    "outputId": "5817f356-361a-49a3-d647-54aca03fd9c6"
   },
   "outputs": [],
   "source": [
    "from sklearn.linear_model import LinearRegression\n",
    "import numpy as np\n",
    "\n",
    "brackets = {}\n",
    "\n",
    "for brack in pitchers['salary_bracket'].unique():\n",
    "  brackets[brack] = pitchers.loc[pitchers['salary_bracket'] == brack, 'interaction_term'].mean()\n",
    "\n",
    "\n",
    "y = np.array(list(brackets.keys())).reshape(-1,1)\n",
    "x = np.array(list(brackets.values())).reshape(-1,1)\n",
    "\n",
    "#Initialize and fit the model\n",
    "reg_pitch = LinearRegression()\n",
    "reg_pitch.fit(x, y)\n",
    "\n",
    "plt.plot(x, reg_pitch.predict(x))\n",
    "\n",
    "plt.scatter(brackets.values(), brackets.keys())\n",
    "plt.xlabel(\"Interaction Term\")\n",
    "plt.ylabel(\"Salary Bracket\")\n",
    "plt.title(\"Salary bracket based on interaction term\")\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "r4KTNDZKi2BQ"
   },
   "source": [
    "That looks pretty promising. Let's calculate the R-squared value to make sure there is a correlation between the interaction term and the salary bracket."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "7y4Wwek4i2BR",
    "outputId": "9198e0a7-a38e-415d-811c-702c87052dae"
   },
   "outputs": [],
   "source": [
    "# compute with formulas from the theory\n",
    "guess = reg_pitch.predict(x)\n",
    "residuals = sum((y-guess)**2)       \n",
    "total = sum((y-np.mean(y))**2)     \n",
    "r_squared = 1 - residuals/total\n",
    "print(r_squared)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "eWmKhacAi2BR"
   },
   "source": [
    "We see that our R-squared value is .968. That shows a huge correlation between the pitchers performace level and their salary. We can therefore reject our null hypothesis in terms of the pitchers as well."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "CiJlVVkzTIT8"
   },
   "source": [
    "# Conclusion\n",
    "We have looked through player salaries from 1985 through 2016 and analyzed the descrepancies in relevant statistics between the highest and lowest paid players. \n",
    "\n",
    "We hope this will give you insight into what factors teams consider when paying their players and how much specific statistics matter to contracts.\n",
    "\n",
    "Teams value a batter's OPS, AVG, and especially HR as, ultimately, runs scored is the biggest component of the game.\n",
    "\n",
    "Teams value a pitcher's BB%, SO%, ERA, and especially innings pitched as, ultimately, the more quality innings you can provide, the more value you are bringing to your team."
   ]
  }
 ],
 "metadata": {
  "colab": {
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
